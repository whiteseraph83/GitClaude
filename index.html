<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oscurità - Horror Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            cursor: crosshair;
        }

        #revealCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #lightCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body class="bg-black">
    <!-- HUD -->
    <div class="absolute top-0 left-0 right-0 p-4 z-10 pointer-events-none">
        <div class="text-gray-400 text-sm font-mono">
            <div class="bg-gray-900/80 backdrop-blur-sm p-3 rounded-lg inline-block border border-red-900/30">
                <p class="text-red-500">ESPLORA L'OSCURITÀ</p>
                <p class="mt-1">Tieni premuto e muovi il mouse • Raggiungi la porta • Evita i nemici</p>
            </div>
        </div>
    </div>

    <!-- Canvas per le aree rivelate permanentemente -->
    <canvas id="revealCanvas"></canvas>

    <!-- Canvas per la luce del personaggio -->
    <canvas id="lightCanvas"></canvas>

    <script>
        // Setup dei canvas
        const revealCanvas = document.getElementById('revealCanvas');
        const lightCanvas = document.getElementById('lightCanvas');
        const revealCtx = revealCanvas.getContext('2d');
        const lightCtx = lightCanvas.getContext('2d');

        // Dimensioni dello schermo
        let width = window.innerWidth;
        let height = window.innerHeight;

        revealCanvas.width = width;
        revealCanvas.height = height;
        lightCanvas.width = width;
        lightCanvas.height = height;

        // Personaggio (cerchio di luce)
        const player = {
            x: width / 2,
            y: height / 2,
            vx: 0,
            vy: 0,
            targetX: width / 2,
            targetY: height / 2,
            radius: 80, // raggio di illuminazione
            speed: 0.05, // fattore di accelerazione
            friction: 0.92 // attrito per rallentare
        };

        // Variabili di gioco
        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;
        let gameOver = false;
        let gameWon = false;

        // Porta obiettivo (rettangolo bianco)
        const door = {
            x: width * 0.9,
            y: height * 0.1,
            width: 40,
            height: 80
        };

        // Nemici (triangoli rossi)
        const enemies = [
            { x: width * 0.3, y: height * 0.2, size: 20, active: false },
            { x: width * 0.7, y: height * 0.5, size: 20, active: false },
            { x: width * 0.4, y: height * 0.7, size: 20, active: false },
            { x: width * 0.6, y: height * 0.3, size: 20, active: false },
            { x: width * 0.2, y: height * 0.6, size: 20, active: false },
            { x: width * 0.8, y: height * 0.8, size: 20, active: false }
        ];

        // Gestione resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            revealCanvas.width = width;
            revealCanvas.height = height;
            lightCanvas.width = width;
            lightCanvas.height = height;
        });

        // Gestione mouse drag
        lightCanvas.addEventListener('mousedown', (e) => {
            if (gameOver || gameWon) return;
            isMouseDown = true;
            player.targetX = e.clientX;
            player.targetY = e.clientY;
        });

        lightCanvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        lightCanvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        lightCanvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            if (isMouseDown && !gameOver && !gameWon) {
                player.targetX = e.clientX;
                player.targetY = e.clientY;
            }
        });

        // Funzione per disegnare il cerchio di luce con gradiente
        function drawLight(ctx, x, y, radius, opacity = 1) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, `rgba(255, 245, 220, ${0.9 * opacity})`);
            gradient.addColorStop(0.3, `rgba(255, 230, 180, ${0.6 * opacity})`);
            gradient.addColorStop(0.6, `rgba(200, 180, 140, ${0.3 * opacity})`);
            gradient.addColorStop(1, `rgba(100, 80, 60, 0)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
        }

        // Funzione per disegnare un triangolo
        function drawTriangle(ctx, x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x - size, y + size);
            ctx.lineTo(x + size, y + size);
            ctx.closePath();
            ctx.fill();
        }

        // Funzione per aggiornare la fisica del movimento
        function updatePlayer() {
            if (gameOver || gameWon) return;

            if (isMouseDown) {
                const dx = player.targetX - player.x;
                const dy = player.targetY - player.y;

                // Accelerazione verso il target
                player.vx += dx * player.speed;
                player.vy += dy * player.speed;

                // Applica attrito
                player.vx *= player.friction;
                player.vy *= player.friction;
            } else {
                // Rallenta gradualmente quando il mouse non è premuto
                player.vx *= 0.85;
                player.vy *= 0.85;

                if (Math.abs(player.vx) < 0.1) player.vx = 0;
                if (Math.abs(player.vy) < 0.1) player.vy = 0;
            }

            // Aggiorna posizione
            player.x += player.vx;
            player.y += player.vy;

            // Mantieni nei confini dello schermo
            player.x = Math.max(player.radius, Math.min(width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(height - player.radius, player.y));

            // Disegna sul canvas delle aree rivelate (permanente) se si sta muovendo
            if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
                revealCtx.globalCompositeOperation = 'lighten';
                drawLight(revealCtx, player.x, player.y, player.radius, 0.4);
            }
        }

        // Funzione per aggiornare i nemici
        function updateEnemies() {
            if (gameOver || gameWon) return;

            enemies.forEach(enemy => {
                // Controlla se il nemico è illuminato
                if (!enemy.active) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < player.radius * 0.7) {
                        enemy.active = true;
                    }
                }

                // Se il nemico è attivo, insegue il giocatore
                if (enemy.active) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        // Velocità uguale al giocatore
                        const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                        enemy.x += (dx / distance) * speed;
                        enemy.y += (dy / distance) * speed;
                    }

                    // Controlla collisione con il giocatore
                    const collisionDist = Math.sqrt(
                        (player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2
                    );

                    if (collisionDist < player.radius * 0.3 + enemy.size) {
                        gameOver = true;
                        showEndScreen('GAME OVER', 'Sei stato catturato dall\'oscurità!', '#dc2626');
                    }
                }
            });
        }

        // Funzione per controllare la vittoria
        function checkDoorCollision() {
            if (gameOver || gameWon) return;

            if (player.x > door.x && player.x < door.x + door.width &&
                player.y > door.y && player.y < door.y + door.height) {
                gameWon = true;
                showEndScreen('VITTORIA!', 'Sei riuscito a fuggire dall\'oscurità!', '#16a34a');
            }
        }

        // Funzione per mostrare la schermata finale
        function showEndScreen(title, message, color) {
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 flex items-center justify-center z-20';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            overlay.innerHTML = `
                <div class="text-center">
                    <h1 class="text-6xl font-bold mb-4" style="color: ${color}">${title}</h1>
                    <p class="text-2xl text-gray-300 mb-8">${message}</p>
                    <button onclick="location.reload()" class="bg-gray-700 hover:bg-gray-600 text-white px-8 py-3 rounded-lg text-xl font-semibold cursor-pointer">
                        Riprova
                    </button>
                </div>
            `;
            document.body.appendChild(overlay);
        }

        // Loop di gioco
        function gameLoop() {
            // Pulisci il canvas della luce corrente
            lightCtx.clearRect(0, 0, width, height);

            // Sfondo scuro
            lightCtx.fillStyle = '#0a0a0a';
            lightCtx.fillRect(0, 0, width, height);

            // Aggiorna e disegna nemici
            updateEnemies();
            enemies.forEach(enemy => {
                if (enemy.active) {
                    drawTriangle(lightCtx, enemy.x, enemy.y, enemy.size, '#dc2626');
                }
            });

            // Disegna la porta (sempre visibile se illuminata)
            lightCtx.fillStyle = '#ffffff';
            lightCtx.fillRect(door.x, door.y, door.width, door.height);

            // Aggiorna il personaggio
            updatePlayer();

            // Controlla collisione con la porta
            checkDoorCollision();

            // Disegna la luce corrente del personaggio (più intensa)
            lightCtx.globalCompositeOperation = 'lighter';
            drawLight(lightCtx, player.x, player.y, player.radius, 1);

            // Effetto pulsante sottile
            const pulseRadius = player.radius + Math.sin(Date.now() * 0.003) * 5;
            drawLight(lightCtx, player.x, player.y, pulseRadius * 0.5, 0.3);

            requestAnimationFrame(gameLoop);
        }

        // Inizializza il gioco
        function init() {
            // Sfondo nero completo
            revealCtx.fillStyle = '#000000';
            revealCtx.fillRect(0, 0, width, height);

            lightCtx.fillStyle = '#000000';
            lightCtx.fillRect(0, 0, width, height);

            // Disegna la posizione iniziale
            drawLight(revealCtx, player.x, player.y, player.radius, 0.4);

            // Avvia il loop
            gameLoop();
        }

        // Avvia il gioco
        init();
    </script>
</body>
</html>
